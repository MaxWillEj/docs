---
title: Developer Guide
description: Local development setup and workflows
icon: terminal
---
# Developer Guide - Tydli Platform

This document serves as a comprehensive developer guide for the API Docs to MCP Server platform (Tydli), outlining its architecture, setup, technologies, and best practices.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Development Setup](#development-setup)
3. [Tech Stack](#tech-stack)
4. [Design System](#design-system)
5. [Authentication](#authentication)
6. [Database Schema](#database-schema)
7. [Edge Functions](#edge-functions)
8. [Testing](#testing)
9. [Performance Optimization](#performance-optimization)
10. [Debugging](#debugging)
11. [Code Standards](#code-standards)
12. [Deployment](#deployment)

## Architecture Overview

### Frontend

The frontend is built with **React 18**, **TypeScript**, **Tailwind CSS**, and **shadcn/ui** components. The project structure follows a modular organization:

```
src/
├── components/          # Reusable React components
│   ├── ui/             # shadcn/ui components
│   ├── auth/           # Authentication components
│   ├── onboarding/     # Onboarding flow components
│   └── ...             # Feature-specific components
├── pages/              # Route-level page components
│   ├── LandingPage.tsx
│   ├── Dashboard.tsx
│   ├── Auth.tsx
│   ├── Settings.tsx
│   ├── Billing.tsx
│   ├── NotFound.tsx
│   └── ...
├── hooks/              # Custom React hooks
│   ├── useAuth.tsx
│   ├── useAnalytics.ts
│   ├── useCredentialSecurity.ts
│   └── ...
├── integrations/       # External service integrations
│   └── supabase/
│       ├── client.ts   # Auto-generated, do not edit
│       └── types.ts    # Auto-generated, do not edit
└── lib/                # Utility functions
    ├── utils.ts
    └── posthog.ts
```

### Backend

The backend leverages **Supabase** for:
- **Edge Functions** (Deno runtime) - See `supabase/functions/` directory for complete list
- **PostgreSQL Database** - Complete schema in [DATABASE_SCHEMA.md](./DATABASE_SCHEMA.md)
- **Authentication** - Built-in auth with email verification
- **Storage** - File storage for API specifications (api-specs bucket)

```
supabase/
├── functions/          # Edge Functions (Deno)
│   ├── ai-doc-to-mcp/
│   ├── validate-openapi/
│   ├── rate-limited-validate-openapi/
│   ├── generate-mcp-server/
│   ├── mcp-router/
│   ├── mcp-oauth-server/
│   ├── manage-deployment/
│   ├── store-credentials/
│   ├── retrieve-credentials/
│   ├── send-auth-email/
│   ├── verify-email/
│   ├── create-verification-token/
│   ├── posthog-analytics/
│   └── fetch-url/
├── migrations/         # Database migrations (read-only)
└── config.toml        # Supabase configuration
```

## Development Setup

### Prerequisites

- **Node.js 18+** (LTS recommended)
- **Git** for version control
- **Supabase CLI** (optional, for local development)

### Local Development

1. **Clone the Repository**
   ```bash
   git clone <repository-url>
   cd tydli
   ```

2. **Install Dependencies**
   ```bash
   npm install
   ```

3. **Environment Variables**
   
   The following environment variables are automatically managed by Supabase:
   - `VITE_SUPABASE_URL` - Supabase project URL
   - `VITE_SUPABASE_PUBLISHABLE_KEY` - Supabase anon key
   - `VITE_SUPABASE_PROJECT_ID` - Supabase project ID

   **CRITICAL**: Never manually edit the `.env` file. It is auto-generated.

4. **Run Development Server**
   ```bash
   npm run dev
   ```

   The application will be available at `http://localhost:5173`

### Supabase Local Development (Optional)

```bash
# Start Supabase locally
supabase start

# Apply migrations
supabase db push

# Deploy edge functions locally
supabase functions serve
```

## Tech Stack

### Frontend Dependencies

- **React 18.3.1** - UI library
- **TypeScript 5.x** - Type safety
- **Vite** - Build tool and dev server
- **Tailwind CSS 3.x** - Utility-first CSS
- **shadcn/ui** - Pre-built component library
- **React Router DOM 6.x** - Client-side routing
- **React Query (@tanstack/react-query)** - Server state management
- **React Dropzone** - File upload handling
- **PostHog** - Analytics and feature flags
- **Zod** - Runtime type validation

### Backend Technology

- **Supabase** - Backend-as-a-Service
- **PostgreSQL 15** - Relational database
- **Deno 1.x** - Edge Functions runtime
- **Row Level Security (RLS)** - Database-level authorization
- **pgcrypto** - AES-256 credential encryption

## Design System

### Semantic Color Tokens

The platform uses a semantic color system defined in `src/index.css` and `src/tailwind.config.ts`:

```css
/* src/index.css */
:root {
  --primary: 210 100% 50%;      /* HSL format */
  --secondary: 280 60% 50%;
  --accent: 30 80% 55%;
  --background: 0 0% 100%;
  --foreground: 222 47% 11%;
  /* ... more semantic tokens */
}
```

**CRITICAL**: Always use semantic tokens, never direct colors:
```tsx
// ✅ CORRECT
<div className="bg-primary text-background" />

// ❌ WRONG
<div className="bg-blue-500 text-white" />
```

### Component Patterns

All shadcn/ui components are located in `src/components/ui/` and follow consistent patterns:
- Use `className` prop for styling
- Support variants via `class-variance-authority`
- Export both component and type definitions
- Include proper TypeScript types

## Authentication

### Supabase Auth Implementation

The platform uses Supabase Auth with **email verification required** (auto-confirm is FALSE).

**Key Authentication Files:**
- `src/hooks/useAuth.tsx` - Authentication hook with session management
- `src/pages/Auth.tsx` - Login/signup page with email verification
- `supabase/functions/send-auth-email/` - Email verification sender (via Resend)
- `supabase/functions/verify-email/` - Email verification handler
- `supabase/functions/create-verification-token/` - Token generation and email trigger

**Authentication Flow:**
1. User signs up with email and password in `src/pages/Auth.tsx`
2. Frontend calls `create-verification-token` Edge Function
3. Edge Function generates secure token, stores in `email_verification_tokens` table
4. Edge Function invokes `send-auth-email` to send verification email via Resend
5. User clicks verification link in email: `https://[domain]/?token=...&type=email_verification`
6. Frontend detects URL params, calls `verify-email` Edge Function
7. Edge Function validates token and updates user's `email_confirmed_at` via Supabase Admin API
8. User can now log in (unverified users are blocked with specific error message)

**CRITICAL Security Rules:**
- ✅ Store complete session object (user + session)
- ✅ Use `onAuthStateChange` for session updates
- ✅ Set `emailRedirectTo` to `${window.location.origin}/` in signup
- ✅ Never use `async` functions as `onAuthStateChange` callbacks
- ✅ Never call Supabase functions inside `onAuthStateChange` directly
- ✅ Check `user.email_confirmed_at` exists before allowing login

```typescript
// CORRECT Implementation (src/hooks/useAuth.tsx)
useEffect(() => {
  // Set up listener FIRST
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    (event, session) => {
      setSession(session);
      setUser(session?.user ?? null);
    }
  );

  // THEN check for existing session
  supabase.auth.getSession().then(({ data: { session } }) => {
    setSession(session);
    setUser(session?.user ?? null);
  });

  return () => subscription.unsubscribe();
}, []);

// Email verification check in login (src/pages/Auth.tsx)
const { data, error } = await supabase.auth.signInWithPassword({
  email: loginEmail,
  password: loginPassword,
});

if (!error && data.user) {
  if (!data.user.email_confirmed_at) {
    setLoginError('Please verify your email address before logging in.');
    await supabase.auth.signOut();
    return;
  }
}
```

## Database Schema

The platform uses a comprehensive PostgreSQL database schema with Row Level Security (RLS) on all tables.

**For complete database documentation**, including all tables, columns, data types, indexes, RLS policies, triggers, and database functions, see [Database Schema Documentation](./DATABASE_SCHEMA.md).

**Quick Overview of Table Categories:**
- **User Management**: profiles, user_roles, user_limits, plan_templates
- **API Specifications**: api_specs, api_credentials
- **Deployments**: deployments, mcp_endpoints, mcp_server_registry, deployment_logs, tool_invocation_logs
- **OAuth 2.1**: oauth_clients, oauth_authorization_codes, oauth_access_tokens, oauth_refresh_tokens, oauth_pending_auth, oauth_rate_limits
- **Security & Monitoring**: security_events, request_usage_tracking, email_verification_tokens, ai_usage_tracking

### RLS Policies

Every table has Row Level Security enabled. Key patterns:

```sql
-- User-owned data
CREATE POLICY "Users view own data"
ON public.profiles FOR SELECT
USING (auth.uid() = user_id);

-- Admin-only access (uses security definer function to avoid RLS recursion)
CREATE POLICY "Admins view all"
ON public.user_roles FOR SELECT
USING (public.has_role(auth.uid(), 'admin'));

-- Service role access
CREATE POLICY "Service role manages"
ON public.oauth_clients FOR ALL
USING ((auth.jwt() ->> 'role'::text) = 'service_role'::text);
```

### Database Functions

Key functions for security and operations:

- `encrypt_credential(plaintext, encryption_key)` - AES-256 encryption via pgcrypto
- `decrypt_credential(ciphertext, encryption_key)` - AES-256 decryption
- `has_role(user_id, role)` - Role checking (security definer, prevents RLS recursion)
- `assign_plan_to_user(user_id, plan_name)` - Admin-only plan assignment
- `assign_plan_to_user_internal(user_id, plan_name)` - Internal plan assignment (no admin check)
- `can_create_deployment(user_id, endpoint_count)` - Limit enforcement
- `check_rate_limits(user_id)` - Rate limit checking (hourly/monthly)
- `get_user_limits(user_id)` - User plan limits
- `log_security_event(event_type, event_details, user_id)` - Security logging
- `store_oauth_state(...)` - OAuth state management with PKCE
- `retrieve_oauth_state(state_token)` - OAuth state retrieval (one-time use)
- `check_oauth_rate_limit(identifier, endpoint, max_requests, window_minutes)` - OAuth rate limiting
- `validate_redirect_uris(uris)` - URI validation (HTTPS required except localhost)
- `cleanup_expired_oauth_data()` - Maintenance cleanup

## Edge Functions

### Error Handling Standards

All edge functions use a standardized error handling system for consistent client experiences and easier debugging.

#### Using the Error Handling Wrapper

```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { withErrorHandling, HandlerContext } from '../_shared/handler-wrapper.ts';
import { createError } from '../_shared/errors.ts';
import { successResponse } from '../_shared/response-builder.ts';

serve(
  withErrorHandling(
    async (req, { supabase, user_id, request_id }: HandlerContext) => {
      // Your business logic here
      
      // Throw standardized errors
      if (!someCondition) {
        throw createError('INVALID_INPUT', 'Invalid request parameter', {
          details: 'Parameter X must be a valid email address',
          context: { parameter: 'email', value: providedValue },
        });
      }
      
      // Return success response
      return successResponse({ success: true, data: result });
    },
    {
      requireAuth: true,
      operation: 'my_operation_name',
    }
  )
);
```

#### Standard Error Codes

- **Authentication/Authorization:**
  - `INVALID_TOKEN` / `TOKEN_EXPIRED` - JWT token issues
  - `UNAUTHORIZED` - Missing authentication
  - `EMAIL_NOT_VERIFIED` - Email verification required
  - `FORBIDDEN` - Insufficient permissions

- **Validation:**
  - `INVALID_INPUT` / `VALIDATION_FAILED` - Input validation errors
  - `MISSING_REQUIRED_FIELD` - Required field missing
  - `SPEC_TOO_LARGE` - File size exceeds limit

- **Rate Limiting:**
  - `RATE_LIMIT_EXCEEDED` / `QUOTA_EXCEEDED` - Too many requests

- **Resources:**
  - `NOT_FOUND` / `DEPLOYMENT_NOT_FOUND` / `SPEC_NOT_FOUND` - Resource not found
  - `ALREADY_EXISTS` - Resource already exists

- **Server Errors:**
  - `INTERNAL_ERROR` / `DATABASE_ERROR` / `ENCRYPTION_FAILED` - Server-side errors
  - `EXTERNAL_API_ERROR` / `AI_PROCESSING_FAILED` - External service errors

#### Creating Errors

```typescript
// Simple error
throw createError('UNAUTHORIZED', 'User not authenticated');

// Error with user-facing details
throw createError('INVALID_INPUT', 'Invalid email format', {
  details: 'Email must be a valid email address',
  context: { field: 'email' },
});

// Error with internal details (never sent to client)
throw createError('DATABASE_ERROR', 'Failed to save deployment', {
  internal_message: `PostgreSQL error: ${pgError.message}`,
  context: { table: 'deployments', deployment_id },
});
```

#### Client Error Response

All errors return this standardized format:

```json
{
  "error": "INVALID_INPUT",
  "message": "Invalid email format",
  "details": "Email must be a valid email address",
  "request_id": "abc-123-def"
}
```

**CRITICAL:** Internal error details (`internal_message`, `stack`, sensitive `context`) are NEVER sent to clients. They are only logged server-side and in PostHog.

#### Logging and Analytics

All errors are automatically:
- Logged to console with `[INTERNAL]` prefix
- Stored in `deployment_logs` table (if deployment_id available)
- Tracked in PostHog analytics (if user_id available)
- Include `request_id` for correlation

### Function Configuration

All Edge Functions are configured in `supabase/config.toml`:

```toml
[functions.ai-doc-to-mcp]
verify_jwt = true

[functions.validate-openapi]
verify_jwt = true

[functions.rate-limited-validate-openapi]
verify_jwt = true

[functions.mcp-oauth-server]
verify_jwt = false  # Public OAuth endpoints

[functions.generate-mcp-server]
verify_jwt = true

[functions.mcp-router]
verify_jwt = true

[functions.manage-deployment]
verify_jwt = true

[functions.store-credentials]
verify_jwt = true

[functions.retrieve-credentials]
verify_jwt = true

[functions.send-auth-email]
verify_jwt = false  # Public email endpoint

[functions.verify-email]
verify_jwt = false  # Public verification endpoint

[functions.create-verification-token]
verify_jwt = false  # Public token generation

[functions.posthog-analytics]
verify_jwt = true

[functions.fetch-url]
verify_jwt = false  # Public URL fetching
```

### Function Development

**Modern Template (with standardized error handling):**
```typescript
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { withErrorHandling, HandlerContext } from '../_shared/handler-wrapper.ts';
import { createError } from '../_shared/errors.ts';
import { successResponse } from '../_shared/response-builder.ts';

serve(
  withErrorHandling(
    async (req, { supabase, user_id, request_id }: HandlerContext) => {
      // Your business logic
      const data = await req.json();
      
      // Validation
      if (!data.required_field) {
        throw createError('MISSING_REQUIRED_FIELD', 'Required field missing', {
          details: 'The field "required_field" is required',
          context: { field: 'required_field' },
        });
      }
      
      // Database operation
      const { data: result, error: dbError } = await supabase
        .from('my_table')
        .insert(data)
        .select()
        .single();
        
      if (dbError) {
        throw createError('DATABASE_ERROR', 'Failed to save data', {
          internal_message: dbError.message,
          context: { table: 'my_table' },
        });
      }
      
      return successResponse({ success: true, data: result });
    },
    {
      requireAuth: true,
      operation: 'my_operation',
    }
  )
);
```

**Legacy Template (old pattern - do not use for new functions):**
```typescript
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const handler = async (req: Request): Promise<Response> => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Your logic here
    
    return new Response(JSON.stringify({ success: true }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error) {
    console.error('[INTERNAL] Error:', error);
    return new Response(JSON.stringify({ 
      error: 'server_error',
      message: 'Unable to process request'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
};

serve(handler);
```

**CRITICAL Security Rules:**
- ✅ Use standardized error handling (`withErrorHandling` wrapper)
- ✅ Always sanitize error messages (no internal details to client)
- ✅ Use `console.error('[INTERNAL]')` for detailed server logs
- ✅ Use `createError()` with `internal_message` for sensitive details
- ✅ Return standardized error codes for client-side handling
- ✅ `request_id` is automatically included in all responses
- ✅ Never execute raw SQL (use Supabase client methods only)
- ✅ Never use `new Function()` or `eval()` (code execution vulnerability)

### Calling Edge Functions

From frontend:
```typescript
const { data, error } = await supabase.functions.invoke('function-name', {
  body: { key: 'value' }
});
```

**NEVER** use direct HTTP calls to Edge Functions. Always use `supabase.functions.invoke()`.

## Testing

### Current Testing Strategy

- **Manual Testing**: Primary method for feature validation
- **Error Boundaries**: React error boundaries catch runtime errors (`src/components/ErrorBoundary.tsx`)
- **TypeScript**: Compile-time type checking
- **RLS Testing**: Database-level access control verification

### Planned Testing

- Unit tests with Vitest
- Integration tests with Playwright
- E2E tests for critical flows

## Performance Optimization

### Frontend

- **React.memo**: Memoize expensive components
- **Lazy Loading**: Code-split routes with `React.lazy()`
- **Query Caching**: React Query for server state
- **Image Optimization**: Lazy loading images
- **Bundle Analysis**: Monitor bundle size with Vite rollup

### Backend

- **Database Indexing**: Indexes on foreign keys and query columns
- **Connection Pooling**: Supabase handles automatically
- **Edge Function Caching**: Stateless functions for fast cold starts
- **Rate Limiting**: Database functions for efficient limit checks

## Debugging

### Frontend Debugging

1. **React Developer Tools**: Inspect component tree and props
2. **Browser Network Tab**: Monitor API calls
3. **Console Logs**: Use `console.log()` for development
4. **PostHog**: Track user behavior and errors

### Backend Debugging

1. **Supabase Dashboard**: View Edge Function logs
2. **Database Logs**: Check PostgreSQL logs for errors
3. **Edge Function Logs**: View in Supabase Functions dashboard
4. **Local Development**: Test Edge Functions locally with `supabase functions serve`

### Common Issues

**Authentication Issues:**
- Check if email is verified (`email_confirmed_at` not null) in `auth.users` table
- Verify RLS policies allow access
- Ensure JWT token is valid and not expired
- Check `onAuthStateChange` is properly implemented

**Edge Function Issues:**
- Check CORS headers are set correctly
- Verify environment variables (secrets) are set in Supabase dashboard
- Check function logs in Supabase dashboard
- Ensure JWT validation is working (`verify_jwt` setting)

**Email Verification Issues:**
- Check Resend API key is set (`RESEND_API_KEY` secret)
- Verify email domain is validated in Resend dashboard
- Check `email_verification_tokens` table for token status
- Ensure `enable_confirmations = false` in `supabase/config.toml`

## Code Standards

### TypeScript

- Use `strict` mode
- Define explicit types for all functions
- Use interfaces for complex types
- Avoid `any` type

```typescript
// ✅ CORRECT
interface DeploymentConfig {
  name: string;
  apiSpecId: string;
  authMethod: 'oauth' | 'jwt' | 'none';
}

// ❌ WRONG
const config: any = { ... };
```

### React

- Use functional components with hooks
- Prefer named exports over default exports
- Use React.memo for expensive components
- Extract complex logic into custom hooks

### Styling

- Use Tailwind CSS utility classes
- Use semantic color tokens from design system
- All colors must be HSL format
- Create reusable component variants with `cva`

## Deployment

### Automatic Deployment

The platform uses **automatic deployment via Supabase Cloud**:

1. Push code to main branch
2. Supabase automatically:
   - Deploys Edge Functions
   - Applies database migrations
   - Updates frontend build

### Environment Variables

Required Supabase secrets:
- `SUPABASE_URL`
- `SUPABASE_ANON_KEY`
- `SUPABASE_SERVICE_ROLE_KEY`
- `SUPABASE_PUBLISHABLE_KEY`
- `ENCRYPTION_KEY` - For credential encryption (AES-256)
- `LOVABLE_API_KEY` - For AI document processing (Lovable AI)
- `POSTHOG_API_KEY` - For analytics tracking
- `RESEND_API_KEY` - For email sending (verification emails)

### Production Monitoring

- **PostHog**: User analytics and feature flags
- **Supabase Logs**: Edge Function execution logs
- **Database Monitoring**: Query performance and errors
- **Security Events**: Audit log in `security_events` table
- **Deployment Logs**: Stored in `deployment_logs` table

#
